const flashcards = {
  algorithms: [
    { front: "Sliding Window", back: "Contiguous subarrays / substrings with constraints (sum, length, distinct chars)" },
    { front: "Two Pointers", back: "Sorted arrays, pairs, shrinking from both ends" },
    { front: "Binary Search", back: "Sorted or monotonic search space(answer increases/decreases predictably)" },
    { front: "DFS", back: "Deep traversal, recursion, backtracking, path finding, trees, graphs" },
    { front: "BFS", back: "Shortest path, level-order traversal" },
    { front: "Heap", back: "Top K problems (largest/smallest), repeated min/max access" },
    { front: "Dynamic Programming", back: "Overlapping subproblems + optimal substructure" },
    { front: "Greedy", back: "local optimal choices lead to global optimum" }
  ],
  dataStructures: [
    { front: "Array / List", back: "Fast indexing, ordered data, small dynamic size" },
    { front: "Hash Map (dict)", back: "Fast lookup, frequency, counting, caching (O(1) average)" },
    { front: "Set", back: "Uniqueness + fast lookup" },
    { front: "Stack", back: "LIFO, undo, DFS, parentheses problems" },
    { front: "Queue", back: "FIFO, BFS, task scheduling" },
    { front: "Deque", back: "Push/pop both ends, sliding window optimization" },
    { front: "Heap", back: "Quick min/max access repeatedly" },
    { front: "Trie", back: "Prefix search, autocomplete, word dictionaries" },
    { front: "Graph", back: "When relationships matter (networks, dependencies)"},
    { front: "Tree", back: "Hierarchical data, range queries, recursive structure"},
  ]
};
